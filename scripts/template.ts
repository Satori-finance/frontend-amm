import Ajv from 'ajv';
const stringify = require('json-stable-stringify');
import * as TJS from 'typescript-json-schema';

export const TSLINT_DISABLE = `/* eslint-disable */`;
export const GENERATED_COMMENT = `// generated by typescript-json-validator`;

export const IMPORT_AJV = (tsConfig: any): string => {
  return tsConfig.allowSyntheticDefaultImports ||
  (tsConfig.esModuleInterop && /^es/.test(tsConfig.module)) ||
  tsConfig.module === 'system'
    ? `import Ajv from 'ajv';`
    : `import Ajv = require('ajv');`;
};

export const importNamedTypes = (names: string[], relativePath: string) =>
  `import {${names.join(', ')}} from '${relativePath}';`;
export const importDefaultType = (name: string, relativePath: string) =>
  `import ${name} from '${relativePath}';`;
export const importType = (
  name: string,
  relativePath: string,
  {isNamedExport}: { isNamedExport: boolean },
) =>
  isNamedExport
    ? importNamedTypes([name], relativePath)
    : importDefaultType(name, relativePath);

export const declareAJV = (options: Ajv.Options) =>
  `export const ajv = new Ajv(${stringify({
    coerceTypes: false,
    allErrors: true,
    ...options,
  })});

ajv.addMetaSchema(require('ajv/lib/refs/json-schema-draft-06.json'));
`;

export const exportNamed = (names: string[]) => `export {${names.join(', ')}};`;

export const declareSchema = (name: string, schema: TJS.Definition) =>
  `export const ${name} = ${stringify(schema, {space: 2})};`;

export const addSchema = (name: string) => `ajv.addSchema(${name}, '${name}')`;

export const DECLARE_VALIDATE_TYPE = `export type ValidateFunction<T> = ((data: unknown) => data is T) & Pick<Ajv.ValidateFunction, 'errors'>`;
export const validateType = (typeName: string) =>
  `ValidateFunction<${typeName}>`;

export const compileSchema = (schemaName: string, typeName: string) =>
  `ajv.compile(${schemaName}) as ${validateType(typeName)}`;

function typeOf(typeName: string, property: string, schema: TJS.Definition) {
  if (schema.definitions && schema.definitions[typeName]) {
    const typeSchema: TJS.DefinitionOrBoolean = schema.definitions[typeName] as TJS.Definition;

    if (
      typeSchema &&
      typeSchema.properties &&
      Object.keys(typeSchema.properties).includes(property)
    ) {
      return `${typeName}['${property}']`;
    }
  }
  return 'unknown';
}

export const validateKoaRequestOverload = (
  typeName: string,
  schema: TJS.Definition,
) =>
  `export function validateKoaRequest(typeName: '${typeName}'): (ctx: KoaContext) => {
  params: ${typeOf(typeName, 'params', schema)},
  query: ${typeOf(typeName, 'query', schema)},
  body: ${typeOf(typeName, 'body', schema)},
};`;

export const initValidator = (typeName: string) =>
  `const validator${typeName}: any = ajv.getSchema(\`Schema#/definitions/${typeName}\`);`
export const initValidatorFunc = (typeName: string) =>
  `export function parse${typeName}(value: unknown): ${typeName} {
  if (!validator${typeName}) {
    throw new Error(\`No validator defined for Schema#/definitions/${typeName}\`)
  }

  const valid = validator${typeName}(value);

  if (!valid) {
    throw new Error(
        'Invalid ' + '${typeName}' + ': ' + ajv.errorsText(validator${typeName}.errors!.filter((e: any) => e.keyword !== 'if'), {dataVar: '${typeName}'}),
    );
  }

  return ${typeName}.fromData(value).convert();
}`
